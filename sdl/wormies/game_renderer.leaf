typedef GLfloat2 : [
	x : GLfloat,
	y : GLfloat,
]

typedef GLfloat3 : [
	r : GLfloat,
	g : GLfloat,
	b : GLfloat,
]

service game_ui_renderer {
	var program : gl_program
	
	var text_title : optional gl_text_texture
	
	var vpos_pos : GLuint
	var tc_pos : GLuint
	var tex_pos : GLuint
	
	var vao : GLuint

	var vertex_data = gl_buffer｢GLfloat2｣( GL_ARRAY_BUFFER )
	var vertex_texcoord = gl_buffer｢GLfloat2｣( GL_ARRAY_BUFFER )
	var index_data = gl_buffer｢GLuint｣( GL_ELEMENT_ARRAY_BUFFER )
	
	defn default = -> construct {
		var r = sdl_ttf_init()
		std.println(["TTF: ", r])
		var font = sdl_ttf_open_font( std.u8_encode( "font/leaf1.TTF" ).raw_ptr, 64 )
		as_abi_ptr(font) == 0 then {
			fail string_tag( "Font load failed" )
		}
	
		text_title = gl_text_texture.from_text( font, "Wormies" )
		
		program.attach_vertex_shader( "wormies/tex_block.vert" )
		program.attach_fragment_shader( "wormies/tex_block.frag" )
		program.link()
	
		vpos_pos = program.get_attrib_location( "vertex_pos" )
		tc_pos = program.get_attrib_location( "tex_coord" )
		tex_pos = program.get_uniform_location( "tex" )
		
		vao = gl_gen_vertex_array()
		gl_bind_vertex_array( vao )
		gl_enable_vertex_attrib_array( vpos_pos )
		gl_enable_vertex_attrib_array( tc_pos )
		
		vertex_data.push( [ -0.5, -0.5 ] )
		vertex_data.push( [ 0.5, -0.5 ] )
		vertex_data.push( [ 0.5, 0.5 ] )
		vertex_data.push( [ -0.5, 0.5 ] )
		vertex_data.bind_and_push( GL_STATIC_DRAW )
		gl_vertex_attrib_pointer( vpos_pos, 2, GL_FLOAT, GL_FALSE, 2 * GLfloat.aligned_value_size, 0 )
		
		index_data.push(0)
		index_data.push(1)
		index_data.push(2)
		index_data.push(3)
		index_data.bind_and_push( GL_STATIC_DRAW )
		
		vertex_texcoord.push( [0,1] )
		vertex_texcoord.push( [1,1] )
		vertex_texcoord.push( [1,0] )
		vertex_texcoord.push( [0,0] )
		vertex_texcoord.bind_and_push( GL_STATIC_DRAW )
		gl_vertex_attrib_pointer( tc_pos, 2, GL_FLOAT, GL_FALSE, 2 * GLfloat.aligned_value_size, 0 )
	}
	
	defn render = ( state : shared game ) -> {
		program.use()
		gl_bind_vertex_array( vao )
		check_gl_error( "vertex_attrib" )
		
		gl_active_texture(GL_TEXTURE0)
		gl_bind_texture(GL_TEXTURE_2D, getopt(text_title).buffer)
		program.set_uniform( tex_pos, 0 )
		
		gl_bind_buffer( GL_ELEMENT_ARRAY_BUFFER, index_data.get_buffer() )
		gl_draw_elements( GL_TRIANGLE_FAN, lossy(index_data.get_size()), GL_UNSIGNED_INT, 0 )
	}
}

service game_renderer {
	var program : gl_program
	var ui : game_ui_renderer
	
	// Attributes/uniforms
	var vpos_pos : GLuint
	var vcolor_pos : GLuint
	var game_size_pos : GLuint
	
	var vertex_data = gl_buffer｢GLfloat2｣( GL_ARRAY_BUFFER )
	var vertex_color = gl_buffer｢GLfloat3｣( GL_ARRAY_BUFFER )
	var index_data = gl_buffer｢GLuint｣( GL_ELEMENT_ARRAY_BUFFER )
	
	var vao : GLuint

	defn default = -> construct {
		program.attach_vertex_shader( "wormies/boxes.vert" )
		program.attach_fragment_shader( "wormies/boxes.frag" )
		program.link()
	
		vpos_pos = program.get_attrib_location( "vertex_pos" )
		vcolor_pos = program.get_attrib_location( "vertex_color" )
		game_size_pos = program.get_uniform_location( "game_size" )
		
		std.println([vertex_data.get_buffer(), " ", vertex_color.get_buffer(), " ", index_data.get_buffer()])
		std.println(["Locations: ", vpos_pos, " ", vcolor_pos, " ", game_size_pos])
		std.println(["Size: ", GLfloat3.aligned_value_size, " ", GLfloat.aligned_value_size])
		
		vao = gl_gen_vertex_array()
		gl_bind_vertex_array( vao )
		gl_enable_vertex_attrib_array( vpos_pos )
		gl_enable_vertex_attrib_array( vcolor_pos )
		
		vertex_data.bind_and_push( GL_DYNAMIC_DRAW )
		gl_vertex_attrib_pointer( vpos_pos, 2, GL_FLOAT, GL_FALSE, 2 * GLfloat.aligned_value_size, 0 )
		
		vertex_color.bind_and_push( GL_DYNAMIC_DRAW )
		gl_vertex_attrib_pointer( vcolor_pos, 3, GL_FLOAT, GL_FALSE, 3 * GLfloat.aligned_value_size, 0 )
	}

	defn _push_box = ( pos : ipoint, color : GLfloat3 ) -> {
		var vdp = lossy｢GLuint｣(vertex_data.get_size())
		
		vertex_data.push( [ lossy(pos.x), lossy(pos.y) ] )
		vertex_data.push( [ lossy(pos.x+1), lossy(pos.y) ] )
		vertex_data.push( [ lossy(pos.x+1), lossy(pos.y+1) ] )
		vertex_data.push( [ lossy(pos.x), lossy(pos.y+1) ] )
		
		vertex_color.push( color )
		vertex_color.push( color )
		vertex_color.push( color )
		vertex_color.push( color )
		
		//TODO: efficiency by damned!  (don't update if not changed)
		index_data.push(vdp + 0)
		index_data.push(vdp + 1)
		index_data.push(vdp + 2)
		
		index_data.push(vdp + 0)
		index_data.push(vdp + 2)
		index_data.push(vdp + 3)
	}
	
	defn render = ( state : shared game ) -> {
		_render_game( state )
		ui.render( state )
	}
	
	defn _render_game = ( state : shared game ) -> {
		vertex_data.clear()
		vertex_color.clear()
		index_data.clear()
		
		var body_color : GLfloat3 = state.alive ? [0.5,0.7,0] | [0.8,0,0]
		for i in std.range(0, state.body.get_size()) {
			_push_box( state.body.get(i), body_color )
		}
		_push_box( state.head_pos, body_color )
		
		_push_box( state.eat_me, [0.9,0.2,0.6] )
	
		program.use()
		gl_bind_vertex_array( vao )
		
		index_data.bind_and_push( GL_DYNAMIC_DRAW )
		vertex_data.bind_and_push( GL_DYNAMIC_DRAW )
		vertex_color.bind_and_push( GL_DYNAMIC_DRAW )
		
		program.set_uniform( game_size_pos, lossy｢GLfloat｣(state.size.x), lossy｢GLfloat｣(state.size.y) )
		
		gl_bind_buffer( GL_ELEMENT_ARRAY_BUFFER, index_data.get_buffer() )
		gl_draw_elements( GL_TRIANGLES, lossy(index_data.get_size()), GL_UNSIGNED_INT, 0 )
	}
	
}
