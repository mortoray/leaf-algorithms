service game_renderer {
	var ui : game_ui_renderer
	var field : game_field_renderer
	
	defn render = ( state : shared game ) -> {
 		field.render( state )
 		ui.render( state )
	}
}


typedef GLfloat2 : [
	x : GLfloat,
	y : GLfloat,
]
defn sub = ( a : GLfloat2, b : GLfloat2 ) -> ( : GLfloat2 ) {
	return [ a.x - b.x, a.y - b.y ]
}
defn mul = ( a : GLfloat2, b : float ) -> ( : GLfloat2 ) {
	return [ lossy(a.x * b), lossy(a.y * b) ]
}
defn add = ( a : GLfloat2, b : GLfloat2 ) -> ( : GLfloat2 ) {
	return [ a.x + b.x, a.y + b.y ]
}
defn GLfloat2_from = ( a : ipoint ) -> ( : GLfloat2 ) {
	return [ lossy(a.x), lossy(a.y) ]
}
defn normalize = ( a : GLfloat2 ) -> ( : GLfloat2 ) {
	var len = math.pow(a.x*a.x + a.y*a.y, 0.5)
	return [ lossy(a.x / len), lossy(a.y / len) ]
}

defn identity_mat4 = -> ( : GLmat4 ) {
	var m : GLmat4
	m.m11 = 1
	m.m12 = 0
	m.m13 = 0
	m.m14 = 0
	m.m21 = 0
	m.m22 = 1
	m.m23 = 0
	m.m24 = 0
	m.m31 = 0
	m.m32 = 0
	m.m33 = 1
	m.m34 = 0
	m.m41 = 0
	m.m42 = 0
	m.m43 = 0
	m.m44 = 1
	return m
}

//limits to +/-1 on either axis assuming a wrap
defn wrap_normal = ( a : ipoint ) -> ( : ipoint ) {
	return [
		a.x < -1 ? 1 | (a.x > 1 ? -1 | a.x),
		a.y < -1 ? 1 | (a.y > 1 ? -1 | a.y)
	]
}

typedef GLfloat3 : [
	r : GLfloat,
	g : GLfloat,
	b : GLfloat,
]

defn lossy_glfloat3 = ( v ) -> ( : GLfloat3 ) {
	return [ lossy(v#0), lossy(v#1), lossy(v#2) ]
}

defn clamp = param｢T｣( a : T, mn : T, mx : T ) -> ( : T ) {
	return a < mn ? mn | (a > mx ? mx | a)
}

//  Assume 0 <=  a,b <= 2*pi
defn close_angle = ( a : float, b : float ) -> {
	var diff = math.abs(a - b)
	diff < 0.1 then return true
	diff > (2*math.pi-0.1) then return true
	return false
}
//  0 when equal, 1 at 90 (basically dot-product like)
defn angle_offset = ( a : float, b : float ) -> {
	var diff = math.abs(a - b)
	diff > math.pi then diff = 2*math.pi - diff

	return clamp｢float｣( diff / (math.pi/2), 0, 1 )
}
defn lerp = ( a : GLfloat3, b : GLfloat3, t : float ) -> {
	return [
		(b.r - a.r) * t + a.r,
		(b.g - a.g) * t + a.g,
		(b.b - a.b) * t + a.b
	]
}

defn max = (a,b) -> {
	return a < b ? b | a
}
defn min = (a,b) -> {
	return a < b ? a | b
}

//assuming segments are beside each other
//from a -> b
defn segment_point_angle = ( a : ipoint, b : ipoint ) -> {
	b.x > a.x then return 0
	b.x < a.x then return math.pi
	b.y > a.y then return math.pi/2
	return 3*math.pi/2
}

service game_ui_renderer {
	var program : gl_program
	
	//TODO: shouldn't need to be optional, initalized in `default`
	var text_title : optional gl_text_texture
	var text_score : optional gl_text_texture
	
	var vpos_pos : GLuint
	var tc_pos : GLuint
	var tex_pos : GLuint
	var placement_pos : GLuint
	
	var vao : GLuint

	var vertex_data = gl_buffer｢GLfloat2｣( GL_ARRAY_BUFFER )
	var vertex_texcoord = gl_buffer｢GLfloat2｣( GL_ARRAY_BUFFER )
	var index_data = gl_buffer｢GLuint｣( GL_ELEMENT_ARRAY_BUFFER )

	var last_score : integer  = 0
	
	var font : SDL_TTF_Font value_ptr
	
	defn default = -> construct {
		var r = sdl_ttf_init()
		std.println(["TTF: ", r])
		font = sdl_ttf_open_font( std.u8_encode( "font/leaf1.TTF" ).raw_ptr, 64 )
		as_abi_ptr(font) == 0 then {
			fail string_tag( "Font load failed" )
		}
	
		text_title = gl_text_texture.from_text( font, "Wormies" )
		text_score = gl_text_texture.from_text( font, "0" )
		
		program.attach_vertex_shader( "wormies/tex_block.vert" )
		program.attach_fragment_shader( "wormies/tex_block.frag" )
		program.link()
	
		vpos_pos = program.get_attrib_location( "vertex_pos" )
		tc_pos = program.get_attrib_location( "tex_coord" )
		tex_pos = program.get_uniform_location( "tex" )
		placement_pos = program.get_uniform_location( "placement" )
		
		vao = gl_gen_vertex_array()
		gl_bind_vertex_array( vao )
		gl_enable_vertex_attrib_array( vpos_pos )
		gl_enable_vertex_attrib_array( tc_pos )
		
		vertex_data.push( [ 0, 0 ] )
		vertex_data.push( [ 1, 0 ] )
		vertex_data.push( [ 1, 1 ] )
		vertex_data.push( [ 0, 1 ] )
		vertex_data.bind_and_push( GL_STATIC_DRAW )
		gl_vertex_attrib_pointer( vpos_pos, 2, GL_FLOAT, GL_FALSE, 2 * GLfloat.aligned_value_size, 0 )
		
		index_data.push(0)
		index_data.push(1)
		index_data.push(2)
		index_data.push(3)
		index_data.bind_and_push( GL_STATIC_DRAW )
		
		vertex_texcoord.push( [0,1] )
		vertex_texcoord.push( [1,1] )
		vertex_texcoord.push( [1,0] )
		vertex_texcoord.push( [0,0] )
		vertex_texcoord.bind_and_push( GL_STATIC_DRAW )
		gl_vertex_attrib_pointer( tc_pos, 2, GL_FLOAT, GL_FALSE, 2 * GLfloat.aligned_value_size, 0 )
	}
	
	defn render = ( state : shared game ) -> {
		state.score != last_score then {
			text_score = gl_text_texture.from_text( font, std.integer_to_ascii(state.score) )
			last_score = state.score
		}
		
		program.use()
		gl_bind_vertex_array( vao )
		check_gl_error( "vertex_attrib" )

		_draw_text( getopt(text_title), [ -0.83, 0.95 ], 0.10 )
		_draw_text( getopt(text_score), [ 0, 0.94 ], 0.1 )
	}
	
	defn _draw_text =  ( text : gl_text_texture, pos : GLfloat2, height : GLfloat ) -> {
		gl_active_texture(GL_TEXTURE0)
		gl_bind_texture(GL_TEXTURE_2D, text.buffer)
		program.set_uniform( tex_pos, 0 )
		
		var src_sz = text.size
		var width = lossy｢GLfloat｣(src_sz.x) / 
			lossy｢GLfloat｣(src_sz.y) * height
		program.set_uniform( placement_pos, pos.x - width/2, pos.y - height/2, width, height)
		
		gl_bind_buffer( GL_ELEMENT_ARRAY_BUFFER, index_data.get_buffer() )
		gl_draw_elements( GL_TRIANGLE_FAN, lossy(index_data.get_size()), GL_UNSIGNED_INT, 0 )
	}
}


service game_field_renderer {
 	var program : gl_program
	
	// Attributes/uniforms
	var vpos_pos : GLuint
	var vcolor_pos : GLuint
	var vnorm_pos : GLuint
	var tc_pos : GLuint
	var game_size_pos : GLuint
	var texture_pos : GLuint
	var transform_pos : GLuint
	
	var vertex_data = gl_buffer｢GLfloat2｣( GL_ARRAY_BUFFER )
	var vertex_color = gl_buffer｢GLfloat3｣( GL_ARRAY_BUFFER )
	var vertex_norm = gl_buffer｢GLfloat3｣( GL_ARRAY_BUFFER )
	var vertex_tex_coord = gl_buffer｢GLfloat2｣( GL_ARRAY_BUFFER )
	var index_data = gl_buffer｢GLuint｣( GL_ELEMENT_ARRAY_BUFFER )
	
	var vao : GLuint
		
	var background_tex : optional gl_texture
	var foreground_tex : optional gl_texture

	defn default = -> construct {
		program.attach_vertex_shader( "wormies/boxes.vert" )
		program.attach_fragment_shader( "wormies/boxes.frag" )
		program.link()
	
		background_tex = gl_texture.from_file( "wormies/assets/background.jpg" )
		foreground_tex = gl_texture.from_file( "wormies/assets/foreground_sprites.png" )
		
		vpos_pos = program.get_attrib_location( "vertex_pos" )
		vcolor_pos = program.get_attrib_location( "vertex_color" )
		vnorm_pos = program.get_attrib_location( "vertex_norm" )
		tc_pos = program.get_attrib_location( "vertex_tex_coord" )
		game_size_pos = program.get_uniform_location( "game_size" )
		texture_pos = program.get_uniform_location( "tex" )
		transform_pos = program.get_uniform_location( "transform" )
		
		std.println([vertex_data.get_buffer(), " ", vertex_color.get_buffer(), " ", index_data.get_buffer()])
		std.println(["Locations: ", vpos_pos, " ", vcolor_pos, " ", game_size_pos])
		std.println(["Size: ", GLfloat3.aligned_value_size, " ", GLfloat.aligned_value_size])
		
		vao = gl_gen_vertex_array()
		gl_bind_vertex_array( vao )
		gl_enable_vertex_attrib_array( vpos_pos )
		gl_enable_vertex_attrib_array( vcolor_pos )
		gl_enable_vertex_attrib_array( vnorm_pos )
		gl_enable_vertex_attrib_array( tc_pos )
		
		vertex_data.bind_and_push( GL_DYNAMIC_DRAW )
		gl_vertex_attrib_pointer( vpos_pos, 2, GL_FLOAT, GL_FALSE, 2 * GLfloat.aligned_value_size, 0 )
		
		vertex_color.bind_and_push( GL_DYNAMIC_DRAW )
		gl_vertex_attrib_pointer( vcolor_pos, 3, GL_FLOAT, GL_FALSE, 3 * GLfloat.aligned_value_size, 0 )
		
		vertex_norm.bind_and_push( GL_DYNAMIC_DRAW )
		gl_vertex_attrib_pointer( vnorm_pos, 3, GL_FLOAT, GL_FALSE, 3 * GLfloat.aligned_value_size, 0 )
		
		vertex_tex_coord.bind_and_push( GL_DYNAMIC_DRAW )
		gl_vertex_attrib_pointer( tc_pos, 2, GL_FLOAT, GL_FALSE, 2 * GLfloat.aligned_value_size, 0 )
	}

	defn _push_dot = ( state : game, dot : game_dot, color : GLfloat3, partial_time : float,
		sprite : [ : integer, : integer ] ) -> {
		var chase_dir = wrap_normal( dot.pos - dot.prev_pos)
		
		_push_box( GLfloat2_from(dot.prev_pos)  + GLfloat2_from(chase_dir) * partial_time, color,
			dot.age < 5 ? lossy｢float｣(dot.age)/5 + partial_time/5 | 1, sprite)
	}
	
	defn _push_box = ( pos : GLfloat2, color : GLfloat3, partial_ : float, sprite : [ : integer, : integer ] ) -> {
		var partial = lossy｢GLfloat｣(partial_)
		var top_left : GLfloat2 = [ pos.x, pos.y ]
		var sz : GLfloat = partial
		
		_push_rect( top_left, [ sz, sz ], color, sprite, 5 )
	}
		
	defn _push_rect = ( pos : GLfloat2, size : GLfloat2, color : GLfloat3, sprite : [ : integer, : integer ], sprite_scale : integer ) -> {
		var vdp = lossy｢GLuint｣(vertex_data.get_size())
		
		vertex_data.push( [ pos.x, pos.y ] )
		vertex_data.push( [ pos.x + size.x, pos.y ] )
		vertex_data.push( [ pos.x + size.x, pos.y + size.y ] )
		vertex_data.push( [ pos.x, pos.y + size.y ] )
		
		vertex_color.push( color )
		vertex_color.push( color )
		vertex_color.push( color )
		vertex_color.push( color )
		
		vertex_norm.push( [ -1, -1, 1 ] )
		vertex_norm.push( [ 1, -1, 1 ] )
		vertex_norm.push( [ 1, 1, 1 ] )
		vertex_norm.push( [ -1, 1, 1 ] )
		
		var sprite_scale_f : GLfloat = 1/lossy｢GLfloat｣(sprite_scale)
		var sx = lossy｢GLfloat｣(sprite#0) * sprite_scale_f
		var sy = lossy｢GLfloat｣(sprite#1) * sprite_scale_f
		
		vertex_tex_coord.push( [ sx, sy+sprite_scale_f ] )
		vertex_tex_coord.push( [ sx+sprite_scale_f, sy+sprite_scale_f ] )
		vertex_tex_coord.push( [ sx+sprite_scale_f, sy ] )
		vertex_tex_coord.push( [ sx, sy ] )
		
		index_data.push(vdp + 0)
		index_data.push(vdp + 1)
		index_data.push(vdp + 2)
		
		index_data.push(vdp + 0)
		index_data.push(vdp + 2)
		index_data.push(vdp + 3)
	}
	
	//TODO: if specifying `float : partial` then untrackable type error
	defn _push_body_segment = ( pos : ipoint, color : GLfloat3,
		prev_seg : optional ipoint, next_seg : optional ipoint, partial : float ) -> {

		var base : GLfloat2 = [ lossy｢GLfloat｣(pos.x) + 0.5, lossy｢GLfloat｣(pos.y) + 0.5 ]
		var dir : GLfloat2 = [0,0]
		
		var opt_prev_angle : optional float
		has(prev_seg) then {
			opt_prev_angle = segment_point_angle(pos, getopt(prev_seg))
			dir = GLfloat2_from( wrap_normal(getopt(prev_seg) - pos) )
		}
		var opt_next_angle : optional float
		has(next_seg) then {
			opt_next_angle = segment_point_angle(pos, getopt(next_seg))
			dir = GLfloat2_from( wrap_normal(getopt(next_seg) - pos) )
		}
		
		base += dir * (1-partial) * 0.5
		
		var vdp = lossy｢GLuint｣(vertex_data.get_size())
		
		vertex_data.push( base ) //vdp#0 == base_pt
		vertex_color.push( color )
		vertex_norm.push( [ 0, 0, 1 ] )
		vertex_tex_coord.push( [ 0.9, 0.9 ] )
		
 		var steps = 32
		for step in std.range(0,steps) {
 			vertex_color.push(color)
 			
 			//TODO: missing one lossy｢float｣ caused error without source
 			var angle = 2*math.pi * (lossy｢float｣(step)/lossy｢float｣(steps));
			//TODO: missing ｢float｣ on clamp had odd issue
 			var rel_x = clamp｢float｣( math.cos( angle )*0.55*partial, -0.5, 0.5)
 			var rel_y = clamp｢float｣( math.sin( angle )*0.55*partial, -0.5, 0.5)
 			vertex_data.push( [
 				lossy(base.x + rel_x ),
 				lossy(base.y + rel_y ),
 			])
 			vertex_tex_coord.push( [ lossy(0.9+rel_x*0.1), lossy(0.9+rel_y*0.1) ] )
 			
 			var a_norm : GLfloat3 = [ 
				lossy｢GLfloat｣(math.cos(angle)), 
				lossy｢GLfloat｣(math.sin(angle)), 
				0 ]
			var b_norm : GLfloat3 = [ 0, 0, 1 ]
 			var ao : float = 1
			has(opt_prev_angle) then {
				ao = min( ao, angle_offset( angle, getopt(opt_prev_angle) ) )
			}
			has(opt_next_angle) then {
				ao = min( ao, angle_offset( angle, getopt(opt_next_angle) ) )
			}
				
			//TODO: should lossy work on an entire tuple?
			vertex_norm.push( lossy_glfloat3( lerp( b_norm, a_norm, math.pow(ao,2) ) ) )
		}
		
		for step in std.range(0, steps) {
			index_data.push( vdp + 0 )
			index_data.push( vdp + 1 + lossy(step) )
			index_data.push( vdp + 1 + lossy(mod(step + 1, steps)) )
		}
	}

	defn _clear_vertex = -> {
		vertex_data.clear()
		vertex_color.clear()
		vertex_norm.clear()
		vertex_tex_coord.clear()
		index_data.clear()
	}
	
	defn render = ( state : shared game ) -> {
		var transform = identity_mat4()
		transform.m22 = 0.95
		transform.m42 = -0.05
		
		program.use()
		gl_bind_vertex_array( vao )
		
		program.set_uniform( game_size_pos, lossy｢GLfloat｣(state.size.x), lossy｢GLfloat｣(state.size.y) )
		gl_program_uniform_matrix_4fv( program.program, transform_pos, 1, GL_FALSE, transform )
		
		_render_background(state, state.partial_time)
		_render_foreground(state, state.partial_time)
	}
	
	defn _render_background = ( state : shared game, partial_time : float ) -> {
		_clear_vertex()
		_push_rect( [ 0,0], [ lossy(state.size.x), lossy(state.size.y) ], [1.2,1.2,1.2], [0,0], 1 )
		_render_vertex(getopt(background_tex).buffer)
	}
	
	defn _render_foreground = ( state : shared game, partial_time : float ) -> {
		_clear_vertex()
		defn get_body_if_valid = ( x : integer ) -> ( : optional ipoint ) {
			x >= 0 and x < state.body.get_size() then return state.body.get(x)
		}
		
		var body_color : GLfloat3 = state.alive ? [0.5,0.7,0] | [0.8,0,0]
		for i in std.range(0, state.body.get_size()) {
			var partial = i == 0 and state.is_body_full() ? 
				1 - partial_time | 
				i == state.body.get_size()-1 ? 
				partial_time | 
				1
			
			_push_body_segment( state.body.get(i), body_color, 
				get_body_if_valid(i-1), 
				get_body_if_valid(i+1),
				partial)
		}
		
		_push_dot( state, state.eat_me, [1,1,1], partial_time, [3,1] )
		_push_dot( state, state.chase_me, [1,1,1], partial_time, [1,2] )
		_render_vertex(getopt(foreground_tex).buffer)
	}
	
	defn _render_vertex = ( sprite_tex : GLuint ) -> {
		index_data.bind_and_push( GL_DYNAMIC_DRAW )
		vertex_data.bind_and_push( GL_DYNAMIC_DRAW )
		vertex_color.bind_and_push( GL_DYNAMIC_DRAW )
		vertex_norm.bind_and_push( GL_DYNAMIC_DRAW )
		vertex_tex_coord.bind_and_push( GL_DYNAMIC_DRAW )
		
		gl_active_texture(GL_TEXTURE0)
		gl_bind_texture(GL_TEXTURE_2D, sprite_tex)
		program.set_uniform( texture_pos,  0)
		
		gl_bind_buffer( GL_ELEMENT_ARRAY_BUFFER, index_data.get_buffer() )
		gl_draw_elements( GL_TRIANGLES, lossy(index_data.get_size()), GL_UNSIGNED_INT, 0 )
	}
	
}
