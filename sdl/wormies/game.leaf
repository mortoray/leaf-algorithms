//TODO: implement == on tuples
typedef ipoint : [
	x : integer,
	y : integer,
]
defn equals = ( a : ipoint, b : ipoint ) -> {
	return a.x == b.x and a.y == b.y
}
defn sub = ( a : ipoint, b : ipoint ) -> ( : ipoint ) {
	return [ a.x - b.x, a.y - b.y ]
}
defn mul = ( a : ipoint, b : integer ) -> ( : ipoint ) {
	return [ a.x * b, a.y * b ]
}
defn add = ( a : ipoint, b : ipoint ) -> ( : ipoint ) {
	return [ a.x + b.x, a.y + b.y ]
}

typedef game_dot : [
	pos : ipoint,
	prev_pos : ipoint,
	dir : ipoint,
	age : integer,
]

literal frame_step_ticks = 150

class game {
	var size : ipoint
	var head_pos : ipoint
	var dir : ipoint
	var body : collections.vector｢ipoint｣
	var req_dir : collections.vector｢ipoint｣
	var body_length : integer = 10
	
	var eat_me : game_dot
	var chase_me : game_dot

	var alive : boolean = true
	var score : integer 
	
	defn default = -> construct {
		size = [ 30, 20 ]
		head_pos = [ rand_integer(0,size.x), rand_integer(0,size.y) ]
		body.add( head_pos )
		_set_next_eat_me()
		_set_next_chase_me()
	}
	
	defn _get_random_eat_loc = -> ( : ipoint ) {
		return [
			rand_integer( 0, size.x ),
			rand_integer( 0, size.y ),
		]
	}
	defn _set_next_eat_me = -> {
		eat_me.pos = _get_random_eat_loc()
		eat_me.prev_pos = eat_me.pos
		eat_me.age = 0
	}
	defn _set_next_chase_me = -> {
		chase_me.pos = _get_random_eat_loc()
		chase_me.prev_pos = chase_me.pos
		chase_me.age = 0
		var dir = rand_integer( 0, 4 )
		chase_me.dir = select(
			dir == 0 ? [1,0],
			dir == 1 ? [-1,0],
			dir == 2 ? [0,1],
			[0,-1],
		)
	}
	
	defn _eaten = ( what : game_dot ) -> {
		equals( head_pos, what.pos ) then return true
		equals( head_pos, what.prev_pos ) then return true
		//body.get_size() > 1 and equals( body.get(body.get_size()-2), what.pos ) then return true
		return false
	}
	
	defn _move = ( xoff : integer, yoff  : integer ) -> {
		//this does wraparound
		//head_pos.x = mod(head_pos.x + xoff, size.x)
		//head_pos.y = mod(head_pos.y + yoff, size.y)
		
		//this kills if hits edge
		head_pos.x = head_pos.x + xoff
		head_pos.y = head_pos.y + yoff
		head_pos.x < 0 or head_pos.x >= size.x or head_pos.y < 0 or head_pos.y >= size.y then {
			alive = false
			return
		}
		
		body.add( head_pos )
		
		body.get_size() > body_length then {
			body.remove(0)
		}
	}
	
	defn is_body_full = -> {
		return body.get_size() >= body_length
	}
	
	var _step_elapsed : float
	var partial_time : float = 1
	
	defn step = ( elapsed : float ) -> {
		alive else {
			partial_time = 1 //may cause blip, but better than nothing appeaering
			return
		}
		
		_step_elapsed += elapsed
		while _step_elapsed > frame_step_ticks {
			_step_quantized()
			_step_check()
			_step_elapsed -= frame_step_ticks
		}
		
		partial_time = _step_elapsed / frame_step_ticks
	}
		
	defn _step_quantized = -> {
		req_dir.get_size() > 0 then {
			dir = req_dir.get(0)
			req_dir.remove(0)
		}
		
		dir.x == 0 and dir.y == 0 else {
			_move( dir.x, dir. y)
		}
		
		eat_me = _step_dot( eat_me )
		chase_me = _step_dot( chase_me )
	}
	
	defn _step_check = -> {
		_eaten( eat_me ) then {
			score += 1
			body_length += 2
			_set_next_eat_me()
		}
		
		_eaten( chase_me ) then {
			score += 2
			body_length += 3
			_set_next_chase_me()
		}
		
		_check_collision()
	}
	
	defn _step_dot = ( what : game_dot ) -> ( : game_dot ) {
		var dot = what
		dot.prev_pos = dot.pos
		dot.pos = [
			mod( dot.pos.x + dot.dir.x, size.x ),
			mod( dot.pos.y + dot.dir.y, size.y ),
		]
		dot.age += 1
		return dot
	}
	
	defn req_move = ( xoff : integer, yoff : integer ) -> {
		req_dir.add( [ xoff, yoff ] )
	}
	
	defn _check_collision = -> {
		_does_collide() else return
		
		alive = false
	}
	
	defn _does_collide = -> ( : boolean ) {
		var at = body.find( (pt) -> {
			return equals( pt, head_pos )
		})
		//TODO: pattern matching somehow
		has(at) then {
			return getopt(at) != body.get_size()-1
		}
		return false
	}
}
